"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var convertors_1 = require("./convertors");
var cloneDeepWith = require("lodash.clonedeepwith");
var classTag = '___js-to-json-class___';
var referenceTag = '___js-to-json-reference___';
var pointerTag = '___js-to-json-pointer___';
var globalScope = typeof global === 'undefined' ? window : global;
var localScope = convertors_1.convertors.reduce(function (scope, _a) {
    var to = _a.to;
    var _b;
    return (tslib_1.__assign({}, scope, (_b = {}, _b[to.prototype.constructor.name] = to, _b)));
}, {});
var referenceId = 0;
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
function nextReferenceId() {
    if (referenceId === MAX_SAFE_INTEGER) {
        referenceId = 0;
    }
    return ++referenceId;
}
function addDataType(cls, from) {
    localScope[cls.prototype.constructor.name] = cls;
    if (from) {
        convertors_1.convertors.push({ from: from, to: cls });
    }
}
exports.addDataType = addDataType;
function toJSON(obj, options) {
    return cloneDeepWith(obj, function (value, index, object, stack) {
        var _a, _b;
        var stacked = stack && stack.get(value);
        if (stacked) {
            stacked[referenceTag] =
                stacked[referenceTag] || "REF_" + nextReferenceId();
            return _a = {}, _a[pointerTag] = stacked[referenceTag], _a;
        }
        var convertor = convertors_1.convertors.find(function (_a) {
            var from = _a.from;
            return value instanceof from;
        });
        if (convertor) {
            value = new convertor.to(value, options);
        }
        if (value && typeof value.toJSON === 'function') {
            return _b = {}, _b[classTag] = value.constructor.name, _b.json = value.toJSON(), _b;
        }
    });
}
exports.toJSON = toJSON;
function fromJSON(obj) {
    var references = {};
    var pointers = [];
    var result = cloneDeepWith(obj, function (value, index, object, stack) {
        if (value) {
            if (value[pointerTag]) {
                pointers.push({
                    pointer: value[pointerTag],
                    object: stack.get(object),
                    index: index,
                });
            }
            else if (index === referenceTag) {
                references[value] = stack.get(object);
            }
            else if (value[classTag]) {
                var cls = globalScope[value[classTag]] || localScope[value[classTag]];
                if (cls) {
                    return cls.fromJSON ? cls.fromJSON(value.json) : new cls(value.json);
                }
                else {
                    return value.json;
                }
            }
        }
    });
    pointers.forEach(function (_a) {
        var pointer = _a.pointer, object = _a.object, index = _a.index;
        object[index] = references[pointer];
        delete references[pointer][referenceTag];
    });
    return result;
}
exports.fromJSON = fromJSON;
//# sourceMappingURL=index.js.map